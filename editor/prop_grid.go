package main

import (
	"log"
	"reflect"
	"sort"
	"strconv"
	"strings"

	"github.com/tlyakhov/gofoom/concepts"

	"github.com/gotk3/gotk3/glib"
	"github.com/tlyakhov/gofoom/core"

	"github.com/gotk3/gotk3/gtk"
)

type GridField struct {
	Name       string
	Values     []reflect.Value
	Type       reflect.Type
	ParentName string
	Depth      int
}

type GridState struct {
	Fields  map[string]*GridField
	Visited map[interface{}]bool
	Depth   int
}

func (e *Editor) PropertyGridFields(obj interface{}, state GridState) {
	v := reflect.ValueOf(obj)
	t := v.Type().Elem()
	if v.IsNil() || t.String() == "main.MapPoint" {
		return
	}

	state.Depth++
	state.Visited[obj] = true

	for i := 0; i < t.NumField(); i++ {
		field := t.FieldByIndex([]int{i})
		display, ok := field.Tag.Lookup("editable")
		if !ok {
			continue
		}

		if display != "^" {
			gf, ok := state.Fields[display]
			if !ok {
				gf = &GridField{
					Name:  display,
					Depth: state.Depth,
					Type:  v.Elem().Field(i).Addr().Type(),
				}
				state.Fields[display] = gf
			}
			gf.Values = append(gf.Values, v.Elem().Field(i).Addr())

			continue
		}

		var child interface{}
		if field.Type.Kind() == reflect.Struct {
			child = v.Elem().Field(i).Addr().Interface()
		} else if field.Type.Kind() == reflect.Ptr {
			child = v.Elem().Field(i).Interface()
		}
		if !state.Visited[child] {
			e.PropertyGridFields(child, state)
		}
	}
}

func (e *Editor) PropertyGridFieldString(index int, field *GridField) {
	origValue := ""
	for i, v := range field.Values {
		if i != 0 {
			origValue += ", "
		}
		origValue += v.Elem().String()
	}

	box, _ := gtk.EntryNew()
	box.SetHExpand(true)
	box.SetText(origValue)
	box.Connect("activate", func(_ *glib.Object) {
		text, err := box.GetText()
		if err != nil {
			log.Printf("Couldn't get text from gtk.Entry. %v\n", err)
			box.SetText(origValue)
			e.PropertyGrid.GrabFocus()
			return
		}
		action := &SetPropertyAction{Editor: e, Fields: field.Values, ToSet: reflect.ValueOf(text)}
		e.NewAction(action)
		action.Act()
		origValue = text
		e.PropertyGrid.GrabFocus()
	})
	e.PropertyGrid.Attach(box, 2, index, 1, 1)
}

func (e *Editor) PropertyGridFieldEnum(index int, field *GridField, enumValues interface{}) {
	// Create our combo box with int/string enum entries.
	rend, _ := gtk.CellRendererTextNew()
	opts, _ := gtk.ListStoreNew(glib.TYPE_INT, glib.TYPE_STRING)
	box, _ := gtk.ComboBoxNewWithModel(opts)
	box.SetHExpand(true)
	box.PackStart(rend, true)
	box.AddAttribute(rend, "text", 1)
	// This is the actual value of this property converted to an int.
	origValue := field.Values[0].Elem().Int()

	// Iterate through all the values of the enum type.
	refEnumValues := reflect.ValueOf(enumValues)
	for i := 0; i < refEnumValues.Len(); i++ {
		listItem := opts.Append()
		enumValue := refEnumValues.Index(i)
		// Our enum should have a String() method generated by the enumer library. Call it.
		enumName := enumValue.MethodByName("String").Call([]reflect.Value{})[0].String()
		// Set the GTK+ list entry.
		opts.Set(listItem, []int{0, 1}, []interface{}{enumValue.Int(), enumName})
		if enumValue.Int() == origValue {
			box.SetActiveIter(listItem)
		}
	}

	box.Connect("changed", func(_ *gtk.ComboBox) {
		selected, _ := box.GetActiveIter()
		value, _ := opts.GetValue(selected, 0)
		value2, _ := value.GoValue()
		action := &SetPropertyAction{Editor: e, Fields: field.Values, ToSet: reflect.ValueOf(value2).Convert(field.Type.Elem())}
		e.NewAction(action)
		action.Act()
	})

	e.PropertyGrid.Attach(box, 2, index, 1, 1)
}

func (e *Editor) PropertyGridFieldFloat64(index int, field *GridField) {
	origValue := ""
	for i, v := range field.Values {
		if i != 0 {
			origValue += ", "
		}
		origValue += strconv.FormatFloat(v.Elem().Float(), 'f', -1, 64)
	}

	box, _ := gtk.EntryNew()
	box.SetHExpand(true)
	box.SetText(origValue)
	box.Connect("activate", func(_ *glib.Object) {
		text, err := box.GetText()
		if err != nil {
			log.Printf("Couldn't get text from gtk.Entry. %v\n", err)
			box.SetText(origValue)
			e.PropertyGrid.GrabFocus()
			return
		}
		f, err := strconv.ParseFloat(strings.TrimSpace(text), 64)
		if err != nil {
			log.Printf("Couldn't parse float64 from user entry. %v\n", err)
			box.SetText(origValue)
			e.PropertyGrid.GrabFocus()
			return
		}
		action := &SetPropertyAction{Editor: e, Fields: field.Values, ToSet: reflect.ValueOf(f)}
		e.NewAction(action)
		action.Act()
		origValue = text
		e.PropertyGrid.GrabFocus()
	})
	e.PropertyGrid.Attach(box, 2, index, 1, 1)
}

func (e *Editor) PropertyGridFieldVector2(index int, field *GridField) {
	origValue := ""
	for i, v := range field.Values {
		if i != 0 {
			origValue += ", "
		}
		origValue += v.Elem().Interface().(concepts.Vector2).String()
	}

	box, _ := gtk.EntryNew()
	box.SetHExpand(true)
	box.SetText(origValue)
	box.Connect("activate", func(_ *glib.Object) {
		text, err := box.GetText()
		if err != nil {
			log.Printf("Couldn't get text from gtk.Entry. %v\n", err)
			box.SetText(origValue)
			e.PropertyGrid.GrabFocus()
			return
		}
		vec, err := concepts.ParseVector2(text)
		if err != nil {
			log.Printf("Couldn't parse Vector2 from user entry. %v\n", err)
			box.SetText(origValue)
			e.PropertyGrid.GrabFocus()
			return
		}
		action := &SetPropertyAction{Editor: e, Fields: field.Values, ToSet: reflect.ValueOf(vec)}
		e.NewAction(action)
		action.Act()
		origValue = vec.String()
		e.PropertyGrid.GrabFocus()
	})
	e.PropertyGrid.Attach(box, 2, index, 1, 1)
}

func (e *Editor) RefreshPropertyGrid() {
	e.PropertyGrid.GetChildren().Foreach(func(child interface{}) {
		e.PropertyGrid.Remove(child.(gtk.IWidget))
	})

	state := GridState{Visited: make(map[interface{}]bool), Fields: make(map[string]*GridField)}
	for _, obj := range e.SelectedObjects {
		e.PropertyGridFields(obj, state)
	}

	sorted := make([]string, len(state.Fields))
	i := 0
	for display := range state.Fields {
		sorted[i] = display
		i++
	}
	sort.SliceStable(sorted, func(i, j int) bool {
		f1 := state.Fields[sorted[i]]
		f2 := state.Fields[sorted[j]]
		if f1.Depth > f2.Depth {
			return true
		} else if f1.Depth < f2.Depth {
			return false
		}
		return f1.Name < f2.Name
	})

	var lastParentName string
	index := 1
	for _, display := range sorted {
		field := state.Fields[display]
		if field.ParentName != lastParentName {
			label, _ := gtk.LabelNew(field.ParentName)
			label.SetJustify(gtk.JUSTIFY_CENTER)
			e.PropertyGrid.Attach(label, 1, index, 2, 1)
			lastParentName = field.ParentName
			index++
		}

		label, _ := gtk.LabelNew(field.Name)
		label.SetJustify(gtk.JUSTIFY_LEFT)
		label.SetHExpand(true)
		label.SetHAlign(gtk.ALIGN_START)
		e.PropertyGrid.Attach(label, 1, index, 1, 1)
		if field.Type.Elem().Kind() == reflect.String {
			e.PropertyGridFieldString(index, field)
		} else if field.Type.Elem().Kind() == reflect.Float64 {
			e.PropertyGridFieldFloat64(index, field)
		} else if field.Type.Elem().String() == "concepts.Vector2" {
			e.PropertyGridFieldVector2(index, field)
		} else if field.Type.Elem().String() == "core.MaterialBehavior" {
			e.PropertyGridFieldEnum(index, field, core.MaterialBehaviorValues())
		} else if field.Type.Elem().String() == "core.CollisionResponse" {
			e.PropertyGridFieldEnum(index, field, core.CollisionResponseValues())
		}
		index++
	}
	e.PropertyGrid.ShowAll()
}
