package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"text/template"

	"golang.org/x/tools/go/packages"
)

/***

SET UP: go install ./ecs/cmd/gofoom_ecs_generator

Then, add `//go:generate gofoom_ecs_generator .` in a file to any directory with
components.

TODO: Bring back some panics/asserts for Get* functions on singletons
(specifically QuadTree and ToneMap)

***/

// attachableTemplate is for boilerplate code for Attachable components.
const attachableTemplate = `
// Code generated by ecs/cmd/gofoom_ecs_generator. DO NOT EDIT.
package {{.PackageName}}

import "tlyakhov/gofoom/ecs"

{{range $name, $v := .Components }}
var {{$name}}CID ecs.ComponentID
{{- end }}

func init() {
{{- range $name, $v := .Components }}
	{{$name}}CID = ecs.RegisterComponent(&ecs.Arena[{{$name}}, *{{$name}}]{})
{{- end }}
}

{{- range $name, $v := .Components }}
func Get{{$name}}(e ecs.Entity) *{{$name}} {
    if asserted, ok := ecs.Component(e, {{$name}}CID).(*{{$name}}); ok {
        return asserted
    }
    return nil
}

func (*{{$name}}) ComponentID() ecs.ComponentID {
    return {{$name}}CID
}
{{- end }}
`

type TemplateData struct {
	Components  map[string]struct{}
	PackageName string
}

// A slice to store the names of structs that embed "Attached".
var componentsByPackage = make(map[*packages.Package]map[string]struct{})
var numComponents = 0

func addComponent(pkg *packages.Package, name string) {
	if _, ok := componentsByPackage[pkg]; !ok {
		componentsByPackage[pkg] = make(map[string]struct{})
	}

	if _, ok := componentsByPackage[pkg][name]; !ok {
		componentsByPackage[pkg][name] = struct{}{}
		numComponents++
	}
}
func inspectTypes(pkg *packages.Package, n ast.Node) bool {
	// We are interested in type specifications (like 'type MyStruct struct { ... }').
	typeSpec, ok := n.(*ast.TypeSpec)
	if !ok {
		return true // Continue traversal
	}

	// We are only interested in struct types.
	structType, ok := typeSpec.Type.(*ast.StructType)
	if !ok {
		return true // Continue traversal
	}

	// Iterate over the fields of the struct.
	for _, field := range structType.Fields.List {
		// An embedded field has no name (field.Names is nil or empty).
		if len(field.Names) != 0 {
			continue
		}

		// We expect a Selector node with "ecs" & "Attached", or alternatively
		// we could have an embedded struct that indirectly embeds that type.
		// For simplicity, we just do multiple passes until we stop finding new
		// types.

		// This is the case for an embedding in the same package.
		if ident, ok := field.Type.(*ast.Ident); ok {
			if _, ok := componentsByPackage[pkg][ident.Name]; ok {
				addComponent(pkg, typeSpec.Name.Name)
			}
			continue
		}

		var selector *ast.SelectorExpr
		if selector, ok = field.Type.(*ast.SelectorExpr); !ok {
			continue
		}

		// We check if the field type is an identifier named "Attached".
		if ident, ok := selector.X.(*ast.Ident); !ok || ident.Name != "ecs" ||
			selector.Sel.Name != "Attached" {
			continue
		}

		// We found a struct that embeds "ecs.Attached".
		// Add its name to our list.

		addComponent(pkg, typeSpec.Name.Name)

		// We can break since we only need to know it embeds it once.
		break
	}
	return true // Continue traversal

}

func main() {
	// --- 1. Argument Handling ---
	// Expect a directory path as the argument.
	if len(os.Args) != 2 {
		log.Fatalf("Usage: %s <directory>", os.Args[0])
	}
	dir := os.Args[1]

	d, _ := os.Getwd()
	log.Printf(d)
	// --- 2. Package Loading ---
	// Configure the package loader. We need to parse syntax trees.
	cfg := &packages.Config{
		Mode:  packages.NeedName | packages.NeedFiles | packages.NeedSyntax,
		Dir:   dir,
		Tests: false, // Don't include test files
	}
	// Load all packages in the specified directory.
	pkgs, err := packages.Load(cfg, "./...")
	if err != nil {
		log.Fatalf("Failed to load packages in directory %s: %v", dir, err)
	}

	// --- 3. AST Traversal & Struct Identification ---

	for {
		prevNum := numComponents
		for _, pkg := range pkgs {
			// Iterate through each file's syntax tree in the package.
			for _, fileNode := range pkg.Syntax {
				// ast.Inspect traverses the AST starting from the root node.
				ast.Inspect(fileNode, func(n ast.Node) bool { return inspectTypes(pkg, n) })
			}
		}
		if numComponents == prevNum {
			break
		}
	}

	// If no relevant structs were found, exit gracefully.
	if numComponents == 0 {
		fmt.Println("No structs embedding 'ecs.Attached' found in the file.")
		return
	}

	// --- 4. Code Generation ---
	// Parse our boilerplate template.
	tmpl, err := template.New("boilerplate").Parse(attachableTemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	for pkg, components := range componentsByPackage {
		// A buffer to hold the generated code.
		var generatedCode bytes.Buffer

		err := tmpl.Execute(&generatedCode, TemplateData{Components: components, PackageName: pkg.Name})
		if err != nil {
			log.Fatalf("Failed to execute template for package %v: %v", pkg.Name, err)
		}

		formattedCode, err := format.Source(generatedCode.Bytes())
		if err != nil {
			log.Printf("warning: internal error: invalid Go generated: %s", err)
			formattedCode = generatedCode.Bytes()
		}

		// We use the directory of the first Go file in the package.
		outputDir := filepath.Dir(pkg.GoFiles[0])
		// A common convention for the generated file name.
		outputFileName := "zz_ecs_generated.go"
		outputFilePath := filepath.Join(outputDir, outputFileName)

		// Write the generated code to the new file.
		err = os.WriteFile(outputFilePath, formattedCode, 0644)
		if err != nil {
			log.Fatalf("Failed to write generated code to file %s: %v", outputFilePath, err)
		}
		fmt.Printf("Successfully generated boilerplate for %d struct(s) in %s\n", len(components), outputFilePath)
	}
}
